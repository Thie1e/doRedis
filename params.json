{"name":"doRedis","tagline":"R/foreach Redis backend for parallel computing","body":"doRedis: A simple parallel backend for foreach using Redis.\r\n\r\nSee https://raw.githubusercontent.com/bwlewis/doRedis/master/vignettes/doRedis.pdf\r\nfor the package vignette, which contains many technical details and examples.\r\n\r\nSee https://github.com/bwlewis/doRedis for the latest examples, bug fixes and\r\ndocumentation.\r\n\r\nIMPORTANT NOTES\r\n\r\ndoRedis now requires Redis versions > 2.6 that support Lua scripting.\r\n\r\nSet the following parameter in your redis.conf file before using doRedis:\r\n\r\ntimeout 0\r\n\r\nDESCRIPTION\r\n\r\nSteve Weston's foreach package is a remarkable parametric evaluation device for\r\nthe R language. Similarly to lapply-like functions, foreach maps expressions to\r\ndata and aggregates results. Even better, foreach lets you do this in parallel\r\nacross multiple CPU cores and computers.  And even better yet, foreach\r\nabstracts the parallel computing details away into modular back-end code. Code\r\nwritten using foreach works sequentially in the absence of a parallel back-end,\r\nand works uniformly across a growing variety of back ends. Think of foreach as\r\nthe lingua Franca of parallel computing for R.\r\n\r\nRedis is a powerful, fast networked database with many innovative features,\r\namong them a blocking stack-like data structure (Redis \"lists\"). This feature\r\nmakes Redis useful as a lightweight backend for parallel computing.  The rredis\r\npackage provides a native R interface to Redis. The doRedis package defines a\r\nsimple parallel backend for foreach that uses Redis.\r\n\r\nHere is a quick example procedure for experimenting with doRedis:\r\n\r\n1. Install Redis on your computer.\r\n2. Install foreach, rredis and doRedis packages.\r\n3. Start the redis server running (see the redis documentation). We assume\r\n   that the server is running on the host \"localhost\" and port 6379 (the\r\n   default Redis port). We assume in the examples below that the worker R\r\n   processes and the master are running on the same machine. In practice,\r\n   they can of course run across a network.\r\n4. Open one or more R sessions that will act as back-end worker processes. \r\n   Run the following in each session:\r\n\r\n   require('doRedis')\r\n   redisWorker('jobs')\r\n\r\n   (The R session will display status messages but otherwise block for work.)\r\n   Note: You can add more workers to a work queue at any time. Also note\r\n   that each back-end worker may advertise for work on multiple queues\r\n   simultaneously (see the documentation and examples).\r\n\r\n5. Open another R session that will act as the master process. Run the\r\n   following example (a simple sampling approximation of pi):\r\n\r\n   require('doRedis')\r\n   registerDoRedis('jobs')\r\n   foreach(j=1:10,.combine=sum,.multicombine=TRUE) %dopar%\r\n            4*sum((runif(1000000)^2 + runif(1000000)^2)<1)/10000000\r\n   removeQueue('jobs')\r\n\r\n\r\nDISCUSSION\r\n\r\nThe \"jobs\" parameter of the redisWorker and registerDoRedis function specifies\r\na Redis \"list\" that will be used to transfer data between the master and worker\r\nprocesses. Think of this name as a reference to a job queue. You are free to\r\nconfigure multiple queues.\r\n\r\nThe doRedis parallel  backend supports dynamic pools of back-end workers.  New\r\nworkers may be added to work queues at any time and can be immediately used by\r\nin-flight foreach computations.\r\n\r\nThe doRedis backend accepts a parameter called \"chunkSize\" that sets the\r\nnumber of function evaluations to be doled out per job. The default value\r\nis one. Increasing chunkSize can improve performance greatly for quick-running\r\nfunction evaluations. Here is an example that sets the chunkSize to 100:\r\n\r\nforeach(j=1:5, .options.redis=list(chunkSize=100)) %dopar%  ...\r\n\r\nSetting chunkSize too large will adversely impact load-balancing across the\r\nworkers.\r\n\r\nThe redisWorker function is used to manually invoke worker processes that\r\nadvertise for jobs on one or more queues. The function also has parameters\r\nfor a Redis host and port number. For example, if the Redis server is\r\nrunning on a host called \"Cazart\" with the default Redis port 6379:\r\n\r\nredisWorker('jobs', host='Cazart', port=6379)\r\n\r\nThe registerDoRedis function also contains host and port parameters. Neither\r\nthe worker nor master R session needs to be running on the same machine as\r\nthe Redis server.\r\n\r\nThe startLocalWorkers function invokes one or more background R worker\r\nprocesses on the local machine (using the redisWorker function). It's\r\na convenient way to invoke several workers at once.\r\n\r\nWorkers self-terminate when their work queues have been deleted with the\r\nremoveQueue function.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}